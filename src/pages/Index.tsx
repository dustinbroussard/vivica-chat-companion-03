import { useState, useEffect, useRef } from "react";
import { Sidebar } from "@/components/Sidebar";
import { ChatHeader } from "@/components/ChatHeader";
import { ChatBody } from "@/components/ChatBody";
import { ChatFooter } from "@/components/ChatFooter";
import { ScrollToBottomButton } from "@/components/ScrollToBottomButton";
import { VoiceAnimation } from "@/components/VoiceAnimation";
import { SettingsModal } from "@/components/SettingsModal";
import { ProfilesModal } from "@/components/ProfilesModal";
import { MemoryModal } from "@/components/MemoryModal";
import { toast } from "sonner";
import { ChatService, ChatMessage } from "@/services/chatService";
import { searchBrave } from "@/services/searchService";
import { Storage } from "@/utils/storage";
import { fetchRSSHeadlines } from "@/services/rssService";
import { getMemories, saveConversationMemory } from "@/utils/memoryUtils";
import { setVoiceModeActive } from "@/js/voice-mode";

function weatherCodeToText(code: number): string {
  const map: Record<number, string> = {
    0: 'Clear sky',
    1: 'Mainly clear',
    2: 'Partly cloudy',
    3: 'Overcast',
    45: 'Fog',
    48: 'Depositing rime fog',
    51: 'Light drizzle',
    53: 'Drizzle',
    55: 'Dense drizzle',
    56: 'Freezing drizzle',
    57: 'Freezing dense drizzle',
    61: 'Slight rain',
    63: 'Rain',
    65: 'Heavy rain',
    66: 'Freezing rain',
    67: 'Heavy freezing rain',
    71: 'Slight snow',
    73: 'Snow',
    75: 'Heavy snow',
    77: 'Snow grains',
    80: 'Slight showers',
    81: 'Showers',
    82: 'Violent showers',
    85: 'Slight snow showers',
    86: 'Heavy snow showers',
    95: 'Thunderstorm',
    96: 'Thunderstorm with hail',
    99: 'Violent thunderstorm'
  };
  return map[code] || 'Unknown';
}

interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: Date;
  failed?: boolean;
  profileId?: string;
}

interface Conversation {
  id: string;
  title: string;
  messages: Message[];
  lastMessage?: string;
  timestamp: Date;
  /** Flag that this conversation title was generated by Vivica */
  autoTitled?: boolean;
}

interface Profile {
  id: string;
  name: string;
  model: string;
  codeModel?: string;
  systemPrompt: string;
  temperature: number;
  maxTokens: number;
  isVivica?: boolean;
  [key: string]: unknown; // Add index signature for console.log compatibility
}

const Index = () => {
  console.log("Index component rendering...");
  
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [currentConversation, setCurrentConversation] = useState<Conversation | null>(null);
  const [currentProfile, setCurrentProfile] = useState<Profile | null>(null);
  const [isTyping, setIsTyping] = useState(false);
  const [showVoiceAnimation, setShowVoiceAnimation] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showProfiles, setShowProfiles] = useState(false);
  const [showMemory, setShowMemory] = useState(false);
  const [isVoiceMode, setIsVoiceMode] = useState(false);
  const [editingMessage, setEditingMessage] = useState<Message | null>(null);
  const chatBodyRef = useRef<HTMLDivElement>(null);
  const [showScrollButton, setShowScrollButton] = useState(false);

  // Initialize default profiles and load data
  useEffect(() => {
    console.log("Index component mounted, initializing...");
    initializeProfiles();
    loadConversations();
    loadCurrentProfile();
    // Drop legacy memory key after migration
    localStorage.removeItem('vivica-memory');
    const handler = () => loadCurrentProfile();
    window.addEventListener('profilesUpdated', handler);
    return () => window.removeEventListener('profilesUpdated', handler);
  }, []);

  // Show/hide the scroll-to-bottom button based on scroll position
  useEffect(() => {
    const el = chatBodyRef.current;
    if (!el) return;
    const onScroll = () => {
      const atBottom =
        el.scrollHeight - el.scrollTop <= el.clientHeight + 16;
      setShowScrollButton(!atBottom);
    };
    el.addEventListener('scroll', onScroll);
    return () => el.removeEventListener('scroll', onScroll);
  }, []);

  // When new messages arrive and the user isn't at the bottom, show the button
  useEffect(() => {
    const el = chatBodyRef.current;
    if (!el) return;
    const atBottom =
      el.scrollHeight - el.scrollTop <= el.clientHeight + 16;
    setShowScrollButton(!atBottom);
  }, [currentConversation?.messages.length, isTyping]);

  // Hide the button when switching conversations
  useEffect(() => {
    setShowScrollButton(false);
  }, [currentConversation?.id]);

  const initializeProfiles = () => {
    const savedProfiles = localStorage.getItem('vivica-profiles');

    let profiles: Profile[] = [];
    if (savedProfiles) {
      try {
        profiles = JSON.parse(savedProfiles);
      } catch {
        profiles = [];
      }
    }

    const hasVivica = profiles.some((p) => p.isVivica);
    if (!hasVivica) {
      // Re-add Vivica if she was removed from storage
      profiles.unshift(Storage.createVivicaProfile());
    }

    if (profiles.length === 0) {
      profiles = [
        Storage.createVivicaProfile(),
        {
          id: '2',
          name: 'Creative Writer',
          model: 'gpt-4',
          systemPrompt:
            'You are a creative writing assistant specializing in storytelling and creative content.',
          temperature: 0.9,
          maxTokens: 3000,
        },
      ];
    }

    localStorage.setItem('vivica-profiles', JSON.stringify(profiles));
  };

  const loadCurrentProfile = () => {
    const savedProfileId = localStorage.getItem('vivica-current-profile');
    const savedProfiles = localStorage.getItem('vivica-profiles');

    if (savedProfiles) {
      let profiles: Profile[] = [];
      try {
        profiles = JSON.parse(savedProfiles);
      } catch {
        profiles = [];
      }

      if (!profiles.some(p => p.isVivica)) {
        // Ensure Vivica always exists
        profiles.unshift(Storage.createVivicaProfile());
        localStorage.setItem('vivica-profiles', JSON.stringify(profiles));
      }
      if (savedProfileId) {
        const profile = profiles.find(p => p.id === savedProfileId);
        if (profile) {
          setCurrentProfile(profile);
          return;
        }
      }
      // Fallback to first profile
      if (profiles.length > 0) {
        setCurrentProfile(profiles[0]);
        localStorage.setItem('vivica-current-profile', profiles[0].id);
      }
    }
  };

  const loadConversations = () => {
    const saved = localStorage.getItem('vivica-conversations');
    const savedCurrent = localStorage.getItem('vivica-current-conversation');
    
    if (saved) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const parsedConversations = JSON.parse(saved).map((conv: any) => ({
        ...conv,
        timestamp: new Date(conv.timestamp),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        messages: conv.messages.map((msg: any) => ({
          ...msg,
          timestamp: new Date(msg.timestamp)
        })),
        autoTitled: conv.autoTitled || false
      }));
      setConversations(parsedConversations);
      
      if (savedCurrent) {
        const current = parsedConversations.find((conv: Conversation) => conv.id === savedCurrent);
        if (current) {
          setCurrentConversation(current);
        }
      } else if (parsedConversations.length > 0) {
        setCurrentConversation(parsedConversations[0]);
      }
    } else {
      handleNewChat();
    }
  };

  // Save conversations to localStorage whenever they change
  useEffect(() => {
    if (conversations.length > 0) {
      localStorage.setItem('vivica-conversations', JSON.stringify(conversations));
    }
  }, [conversations]);

  // Save current conversation ID
  useEffect(() => {
    if (currentConversation) {
      localStorage.setItem('vivica-current-conversation', currentConversation.id);
    }
  }, [currentConversation]);

  const handleProfileChange = (profile: Profile) => {
    setCurrentProfile(profile);
    localStorage.setItem('vivica-current-profile', profile.id);
    toast.success(`Switched to ${profile.name} profile`);
  };

  const getMemoryPrompt = async () => {
    const memoryActive = localStorage.getItem('vivica-memory-active');
    if (memoryActive !== 'true') return '';

    const profileId = localStorage.getItem('vivica-current-profile') || '';
    const parts: Record<string, unknown>[] = [];

    const globalMem = localStorage.getItem('vivica-memory-global');
    const profileMem = profileId
      ? localStorage.getItem(`vivica-memory-profile-${profileId}`)
      : null;

    if (globalMem) {
      try { parts.push(JSON.parse(globalMem)); } catch { /* ignore */ }
    }
    if (profileMem) {
      try { parts.push(JSON.parse(profileMem)); } catch { /* ignore */ }
    }

    // Remove any stale legacy key
    localStorage.removeItem('vivica-memory');

    let prompt = '';
    for (const memory of parts) {
      if (memory.identity?.name) {
        prompt += `The user's name is ${memory.identity.name}. `;
      }
      if (memory.identity?.pronouns) {
        prompt += `Use ${memory.identity.pronouns} pronouns when referring to the user. `;
      }
      if (memory.identity?.occupation) {
        prompt += `The user works as ${memory.identity.occupation}. `;
      }
      if (memory.identity?.location) {
        prompt += `The user is located in ${memory.identity.location}. `;
      }
      if (memory.personality?.tone) {
        prompt += `Adopt a ${memory.personality.tone} tone when responding. `;
      }
      if (memory.personality?.style) {
        prompt += `Use a ${memory.personality.style} communication style. `;
      }
      if (memory.personality?.interests) {
        prompt += `The user is interested in: ${memory.personality.interests}. `;
      }
      if (memory.customInstructions) {
        prompt += `${memory.customInstructions} `;
      }
      if (memory.systemNotes) {
        prompt += `Additional notes: ${memory.systemNotes}`;
      }
    }

    try {
      const globalMems = await getMemories(undefined, 'global');
      const profileMems = await getMemories(profileId, 'profile');
      const combined = [...globalMems, ...profileMems];
      if (combined.length) {
        const list = combined.map(m => `- ${m.content}`).join('\n');
        prompt += `${prompt ? '\n\n' : ''}Stored Facts:\n${list}`;
      }
    } catch (e) {
      console.warn('Failed to load memories from DB', e);
    }

    return prompt.trim();
  };

  const fetchWeatherInfo = async (): Promise<string> => {
    const fallback = { lat: 30.2366, lon: -92.8204, name: 'Welsh, LA' };

    const fetchWeather = async (lat: number, lon: number) => {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&temperature_unit=fahrenheit`;
      try {
        const resp = await fetch(url);
        const data = await resp.json();
        const current = data.current_weather;
        const temp = Math.round(current.temperature) + '°F';
        const condText = weatherCodeToText(current.weathercode);
        return `${condText}, ${temp}`;
      } catch {
        return 'Weather unavailable.';
      }
    };

    return new Promise((resolve) => {
      if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
          async (pos) => {
            const result = await fetchWeather(pos.coords.latitude, pos.coords.longitude);
            resolve(result);
          },
          async () => {
            const result = await fetchWeather(fallback.lat, fallback.lon);
            resolve(result);
          },
          { enableHighAccuracy: false, timeout: 4000, maximumAge: 180000 }
        );
      } else {
        fetchWeather(fallback.lat, fallback.lon).then(resolve);
      }
    });
  };

  const buildSystemPrompt = async () => {
    const profilePrompt = currentProfile?.systemPrompt || 'You are a helpful AI assistant.';
    const memoryPrompt = await getMemoryPrompt();
    const settings = Storage.get('vivica-settings', { includeWeather: false, includeRss: false });

    let prompt = profilePrompt;
    if (memoryPrompt) {
      prompt += `\n\nUser Context: ${memoryPrompt}`;
    }

    if (settings.includeWeather) {
      const weather = await fetchWeatherInfo();
      prompt += `\n\nCurrent Weather: ${weather}`;
    }

    if (settings.includeRss) {
      try {
        const headlines = await fetchRSSHeadlines();
        const list = headlines.slice(0, 5).map(h => `- ${h.title} (${h.source})`).join('\n');
        if (list) {
          prompt += `\n\nCurrent Headlines:\n${list}`;
        }
      } catch (e) {
        console.debug('Failed to fetch headlines', e);
      }
    }

    return prompt;
  };

  const handleNewChat = () => {
    const newConversation: Conversation = {
      id: Date.now().toString(),
      title: 'New Chat',
      messages: [],
      timestamp: new Date(),
      autoTitled: false,
    };
    setConversations(prev => [newConversation, ...prev]);
    setCurrentConversation(newConversation);
    setSidebarOpen(false);
    toast.success("New conversation started!");
  };

  const handleSendMessage = async (content: string, baseConv?: Conversation) => {
    const conversation = baseConv || currentConversation;
    if (!conversation || !content.trim() || !currentProfile) return;


    // Check for a /search command before routing the message to the LLM
    const searchMatch = content.trim().match(/^\/search\s+(.*)/i);

    const userMessage: Message = {
      id: Date.now().toString(),
      content: content.trim(),
      role: 'user',
      timestamp: new Date(),
      profileId: currentProfile.id,
    };

    let updatedConversation = {
      ...conversation,
      messages: [...conversation.messages, userMessage],
      lastMessage: content.trim(),
      timestamp: new Date(),
      title: conversation.messages.length === 0 ?
        content.trim().substring(0, 30) + (content.trim().length > 30 ? '...' : '') :
        conversation.title,
    };

    setCurrentConversation(updatedConversation);
    setConversations(prev => prev.map(conv =>
      conv.id === conversation.id ? updatedConversation : conv
    ));

    setIsTyping(true);

    const apiKey = localStorage.getItem('openrouter-api-key');
    if (!apiKey) {
      toast.error('Please set your OpenRouter API key in Settings.');
      setIsTyping(false);
      return;
    }

    const systemPrompt = await buildSystemPrompt();
    let chatMessages: ChatMessage[] = [
      { role: 'system', content: systemPrompt },
      ...updatedConversation.messages.map(m => ({ role: m.role, content: m.content }))
    ];

    // If this is a /search command, fetch results from Brave Search
    if (searchMatch) {
      const query = searchMatch[1];
      const braveKey = localStorage.getItem('braveApiKey');
      if (!braveKey) {
        toast.error('Please set your Brave Search API key in Settings.');
        setIsTyping(false);
        return;
      }

      try {
        const results = await searchBrave(query, braveKey);
        const formatted = results.map((r, i) => `${i + 1}. **${r.title}**\n${r.description}\n${r.url}`).join('\n\n');

        // Insert the raw search results as a new assistant message
        const resultsMessage: Message = {
          id: (Date.now() + 1).toString(),
          content: `Search results for "${query}":\n\n${formatted}`,
          role: 'assistant',
          timestamp: new Date(),
          profileId: currentProfile.id,
        };

        const convWithResults = {
          ...updatedConversation,
          messages: [...updatedConversation.messages, resultsMessage],
          lastMessage: resultsMessage.content,
          timestamp: new Date(),
        };

        setCurrentConversation(convWithResults);
        setConversations(prev => prev.map(conv => conv.id === conversation.id ? convWithResults : conv));

        // Build a prompt asking Vivica to summarize the results
        chatMessages = [
          { role: 'system', content: systemPrompt },
          ...convWithResults.messages.map(m => ({ role: m.role, content: m.content })),
          { role: 'user', content: 'Summarize or comment on the search results above in your signature style.' }
        ];

        updatedConversation = convWithResults; // continue with new conversation state
      } catch (err) {
        toast.error('Failed to fetch search results.');
        setIsTyping(false);
        return;
      }
    }

    const chatService = new ChatService(apiKey);

    const assistantMessage: Message = {
      id: (Date.now() + 1).toString(),
      content: '',
      role: 'assistant',
      timestamp: new Date(),
      profileId: currentProfile.id,
    };

    const streamingConversation = {
      ...updatedConversation,
      messages: [...updatedConversation.messages, assistantMessage],
      lastMessage: '',
      timestamp: new Date(),
    };

    setCurrentConversation(streamingConversation);
    setConversations(prev => prev.map(conv =>
      conv.id === conversation.id ? streamingConversation : conv
    ));

    try {
      const isCodeReq = /```|\bcode\b|function|programming/i.test(content);
      const response = await chatService.sendMessage({
        model: currentProfile.model,
        messages: chatMessages,
        temperature: currentProfile.temperature,
        max_tokens: currentProfile.maxTokens,
        stream: true,
        isCodeRequest: isCodeReq
      });
      // TODO: if isCodeReq, send full code output to Vivica's model for a human
      // explanation before finalizing the message

      let fullContent = '';
      let isCodeResp = false;
      for await (const chunk of chatService.streamResponse(response, { isCodeRequest: isCodeReq })) {
        if (typeof chunk === 'object' && 'type' in chunk) {
          // Stream start metadata
          if (chunk.type === 'stream_start') {
            isCodeResp = !!chunk.data.isCodeRequest;
          }
          continue;
        }

        const token = typeof chunk === 'string' ? chunk : chunk.content;
        fullContent += token;
        setCurrentConversation(prev => {
          if (!prev) return prev;
          const msgs = prev.messages.map(msg =>
            msg.id === assistantMessage.id ? { ...msg, content: fullContent, isCodeResponse: isCodeResp } : msg
          );
          return { ...prev, messages: msgs, lastMessage: fullContent };
        });
        setConversations(prev => prev.map(conv => {
          if (conv.id !== conversation.id) return conv;
          const msgs = conv.messages.map(msg =>
            msg.id === assistantMessage.id ? { ...msg, content: fullContent, isCodeResponse: isCodeResp } : msg
          );
          return { ...conv, messages: msgs, lastMessage: fullContent, timestamp: new Date() };
        }));

        if (chatBodyRef.current) {
          // Keep auto-scrolling while streaming only if the user is already
          // near the bottom. Otherwise, show the scroll-to-bottom button.
          const el = chatBodyRef.current;
          const atBottom =
            el.scrollHeight - el.scrollTop <= el.clientHeight + 16;
          if (atBottom) {
            el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
          }
        }
      }

      // Conversation finished streaming; attempt auto-title if needed
      const finalMsg = { ...assistantMessage, content: fullContent, isCodeResponse: isCodeResp };
      const finalConv: Conversation = {
        ...updatedConversation,
        messages: [...updatedConversation.messages, finalMsg],
        lastMessage: fullContent,
        timestamp: new Date()
      };
      if (!conversation.autoTitled) {
        await handleGenerateTitle(finalConv);
      }
    } catch (error) {
      const failedMessage: Message = {
        id: assistantMessage.id,
        content: 'Sorry, I encountered an error. Please try again.',
        role: 'assistant',
        timestamp: new Date(),
        failed: true,
        profileId: currentProfile.id,
      };

      const errorConversation = {
        ...updatedConversation,
        messages: [...updatedConversation.messages, failedMessage],
        lastMessage: 'Error occurred',
        timestamp: new Date(),
      };

      setCurrentConversation(errorConversation);
      setConversations(prev => prev.map(conv =>
        conv.id === conversation.id ? errorConversation : conv
      ));

      toast.error('Failed to get AI response. Please try again.');
    } finally {
      setIsTyping(false);
    }
  };

  const handleRetryMessage = (messageId: string) => {
    if (!currentConversation) return;
    
    const messageIndex = currentConversation.messages.findIndex(msg => msg.id === messageId);
    if (messageIndex > 0) {
      const userMessage = currentConversation.messages[messageIndex - 1];
      if (userMessage.role === 'user') {
        const updatedMessages = currentConversation.messages.slice(0, messageIndex);
        const updatedConversation = {
          ...currentConversation,
          messages: updatedMessages
        };
        setCurrentConversation(updatedConversation);
        setConversations(prev => prev.map(conv =>
          conv.id === currentConversation.id ? updatedConversation : conv
        ));

        handleSendMessage(userMessage.content, updatedConversation);
      }
    }
  };

  const handleRegenerateMessage = (messageId: string) => {
    if (!currentConversation) return;

    const messageIndex = currentConversation.messages.findIndex(msg => msg.id === messageId);
    if (messageIndex > 0) {
      const userMessage = currentConversation.messages[messageIndex - 1];
      if (userMessage.role === 'user') {
        const updatedMessages = currentConversation.messages.slice(0, messageIndex);
        const updatedConversation = {
          ...currentConversation,
          messages: updatedMessages
        };
        setCurrentConversation(updatedConversation);
        setConversations(prev => prev.map(conv =>
          conv.id === currentConversation.id ? updatedConversation : conv
        ));

        handleSendMessage(userMessage.content, updatedConversation);
      }
    }
  };

  const handleSendEditedMessage = (content: string) => {
    if (!currentConversation || !editingMessage) return;

    const index = currentConversation.messages.findIndex(m => m.id === editingMessage.id);
    if (index >= 0) {
      const updatedMessages = currentConversation.messages.slice(0, index);
      const updatedConversation = {
        ...currentConversation,
        messages: updatedMessages
      };
      setCurrentConversation(updatedConversation);
      setConversations(prev => prev.map(conv =>
        conv.id === currentConversation.id ? updatedConversation : conv
      ));
      setEditingMessage(null);
      handleSendMessage(content, updatedConversation);
    }
  };

  const handleStartEditMessage = (message: Message) => {
    setEditingMessage(message);
  };


  const handleVoiceToggle = () => {
    const newState = !isVoiceMode;
    setIsVoiceMode(newState);
    setVoiceModeActive(newState);
    if (newState) {
      setShowVoiceAnimation(true);
      toast.success("Voice mode activated");
    } else {
      setShowVoiceAnimation(false);
      toast.success("Voice mode deactivated");
    }
  };

  const handleSelectConversation = (conversation: Conversation) => {
    setCurrentConversation(conversation);
    setSidebarOpen(false);
  };

  const handleDeleteConversation = (conversationId: string) => {
    const newConversations = conversations.filter(conv => conv.id !== conversationId);
    setConversations(newConversations);
    
    if (currentConversation?.id === conversationId) {
      if (newConversations.length > 0) {
        setCurrentConversation(newConversations[0]);
      } else {
        handleNewChat();
      }
    }
    
    toast.success("Conversation deleted");
  };

  const handleRenameConversation = (conversationId: string, newTitle: string) => {
    // Update only the title on the existing object. Using a functional
    // update avoids stale state when rename is triggered asynchronously.
    setConversations(prev =>
      prev.map(conv =>
        conv.id === conversationId ? { ...conv, title: newTitle, autoTitled: true } : conv
      )
    );

    // Keep the currently active conversation object in sync without
    // replacing its id or other fields.
    setCurrentConversation(prev =>
      prev && prev.id === conversationId ? { ...prev, title: newTitle, autoTitled: true } : prev
    );

    toast.success("Conversation renamed");
  };

  /**
   * Summarize the active conversation and store it in IndexedDB.
   * Utilizes saveConversationMemory which calls the model to
   * produce a short recap in Vivica's voice.
   */
  const handleSaveSummary = async () => {
    if (!currentConversation || !currentProfile) return;

    const apiKey = localStorage.getItem('openrouter-api-key');
    if (!apiKey) {
      toast.error('Please set your OpenRouter API key in Settings.');
      return;
    }

    const messages: ChatMessage[] = currentConversation.messages.map(m => ({
      role: m.role,
      content: m.content
    }));

    try {
      await saveConversationMemory(
        messages,
        currentProfile.model,
        apiKey,
        'profile',
        currentProfile.id
      );
    } catch (e) {
      // errors are surfaced via toast in saveConversationMemory
    }
  };

  /**
   * Generate a short, witty title for the given conversation
   * using Vivica's model. Falls back to the existing title
   * if the API call fails.
   */
  const handleGenerateTitle = async (conv?: Conversation) => {
    const conversation = conv || currentConversation;
    if (!conversation || !currentProfile) return;

    const apiKey = localStorage.getItem('openrouter-api-key');
    if (!apiKey) {
      toast.error('Please set your OpenRouter API key in Settings.');
      return;
    }

    // Only re-title when there are at least two messages
    if (conversation.messages.length < 2) return;

    const chatService = new ChatService(apiKey);
    const reqMessages: ChatMessage[] = conversation.messages.map(m => ({
      role: m.role,
      content: m.content
    }));
    reqMessages.push({
      role: 'user',
      content:
        'Give this conversation a title that is short, punchy, and feels like something Vivica would say. Make it witty, mysterious, or teasing—never generic. No more than 6 words. Just the title, nothing else.'
    });

    try {
      const res = await chatService.sendMessage({
        model: currentProfile.model,
        messages: reqMessages,
        temperature: 0.7,
        max_tokens: 12
      });
      const data = await res.json();
      const title = data.choices?.[0]?.message?.content?.trim();
      if (title) {
        // Reuse the same rename logic used by the manual flow so we don't
        // replace the conversation object or lose the active ID.
        handleRenameConversation(conversation.id, title.replace(/^"|"$/g, ''));
      }
    } catch (e) {
      console.warn('Failed to generate title', e);
    }
  };

  const handleScrollToBottom = () => {
    const el = chatBodyRef.current;
    if (!el) return;
    el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
    setShowScrollButton(false);
  };

  console.log("Index component state:", {
    sidebarOpen,
    currentConversation: currentConversation?.id,
    currentProfile: currentProfile?.name,
    conversations: conversations.length
  });

  return (
    <div className="flex h-screen bg-background text-foreground overflow-hidden">
      <Sidebar
        isOpen={sidebarOpen}
        onClose={() => setSidebarOpen(false)}
        conversations={conversations}
        currentConversation={currentConversation}
        onSelectConversation={handleSelectConversation}
        onDeleteConversation={handleDeleteConversation}
        onRenameConversation={handleRenameConversation}
        onGenerateTitle={handleGenerateTitle}
        onNewChat={handleNewChat}
        onOpenSettings={() => setShowSettings(true)}
        onOpenProfiles={() => setShowProfiles(true)}
        onOpenMemory={() => setShowMemory(true)}
      />

      <div className="flex-1 flex flex-col min-w-0 relative">
        <ChatHeader
          onMenuToggle={() => setSidebarOpen(true)}
          currentTitle={currentConversation?.title || "Vivica"}
          currentProfile={currentProfile}
          onProfileChange={handleProfileChange}
          onOpenProfiles={() => setShowProfiles(true)}
          onSaveSummary={handleSaveSummary}
        />
        
        <ChatBody
          ref={chatBodyRef}
          conversation={currentConversation}
          isTyping={isTyping}
          onRetryMessage={handleRetryMessage}
          onRegenerateMessage={handleRegenerateMessage}
          onEditMessage={handleStartEditMessage}
          onSendMessage={handleSendMessage}
          onNewChat={handleNewChat}
        />

        <ScrollToBottomButton
          visible={showScrollButton}
          onClick={handleScrollToBottom}
        />

        <ChatFooter
          onSendMessage={editingMessage ? handleSendEditedMessage : handleSendMessage}
          onVoiceToggle={handleVoiceToggle}
          isVoiceMode={isVoiceMode}
          editingMessage={editingMessage?.content}
        />
      </div>

      {showVoiceAnimation && (
        <VoiceAnimation
          isVisible={showVoiceAnimation}
          onClose={() => {
            setShowVoiceAnimation(false);
            setIsVoiceMode(false);
            setVoiceModeActive(false);
          }}
          currentProfile={currentProfile}
          getMemoryPrompt={getMemoryPrompt}
          buildSystemPrompt={buildSystemPrompt}
          onSendMessage={handleSendMessage}
        />
      )}

      <SettingsModal
        isOpen={showSettings}
        onClose={() => setShowSettings(false)}
      />

      <ProfilesModal
        isOpen={showProfiles}
        onClose={() => setShowProfiles(false)}
      />

      <MemoryModal
        isOpen={showMemory}
        onClose={() => setShowMemory(false)}
      />
    </div>
  );
};

export default Index;
